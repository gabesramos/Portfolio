# Introduction

In YMViewer, a website that manages Yale Intramurals, we deal with 3 primary objects: users, colleges, and games. Each of these 3 categories has its table in the data.db file and communicate with each other through auxiliary tables such as "Registered" that provide information regarding the user IDs that correspond to registered users for a particular game.

# HTML pages

## LOGIN AND REGISTER (login.html and register.html)

First and foremost, there are several security measures in place dealing with user logins and registering of new users. The first is a password that is hashed by applying a hash function. The password also has to meet certain security criteria implemented through a REE (regular expression operations) Python library. The user also must match the admin key to a predetermined value to gain admin status on their account. This process uses the POST method in Flask to communicate securely from the front-end forms to the Python back-end.

Once the user has signed in they gain access to several pages that the user can interact with. The pages available depend on the user's admin status.

## LAYOUT (layout.html)

The user can move from one page to another through the navigation bar which is fixed for all pages using a "layout" html file that extends to all other files using Jinja2.

## For NON-ADMIN users:

### INDEX/HOME PAGE (index.html)

The homepage provides a series of boxes, each corresponding to a game relevant to the user. On the app.py file, relevance to the user is determined by performing an SQL query on the "Games" table through a nested for loop. First, the user's college is determined through the user table. Then, all FUTURE games of the user's respective college are displayed (the two conditionals of this SQL search involve College and a comparison to a current date/time stamp through the DateTime Python library). Games are sorted in descending order in terms of closeness to the current time (closer games are displayed first). The styling on this page involves a custom class element for each of the boxes, with the first div (the one containing the college names) displaying a horizontal gradient of colors representing each of the respective colleges (this was done using a CSS gradient effect on the stylesheet).

### INFO/SIGNUP PAGE (signup.html)

From the home page, the user may submit a GET request to access the info/signup page. This page displays general information about the game such as date, location, and roster. The roster for each team is generated by querying data.db through SQL for all UNIQUE registered users through the "Registered" table. Above the location element is an interactive map. The map is created using the &q query tag with the Google Maps Embed API accompanied by a valid API key. The result returned is presented inside of an iframe HTML component with fixed dimensions. The user may submit a POST request and register for the event, in which case the name will be appended to the registered user's table and presented to all other users who open the game info page.

### STANDINGS PAGE (stats.html)

The table is created using the chart.js library. Colors, values, and names are determined by the values in the "Colleges" table. The ticker rotates through a series of relevant strings using the "Marquee" element in HTML. Data is transferred using flask through Jinja2 and the JSON library. The data must be packaged as JSON through the .dumps method in Python and later unpackaged using the JSON.parse functionality in Javascript. The table below the ticker displays further data regarding the team's standing using Flask and Jinja. certain values such as the "Games Played" and "Score" columns are populated using simple arithmetic of other columns.

### PREVIOUS GAMES (past_games.html)

The previous game's route is accessed through a GET request. It provides a standard bootstrap table where data from the "Games" table from data.db is presented. The page updates dynamically in response to the modifications of the "Games" table. If the date of a game has passed, the game will automatically appear on this page. The same applies if an admin manually updates the score of the game. Under the competing column, the two college's respective coats of arms are displayed and are slightly overlapping. This is done using a CSS styling technique by which the location of both images is fixed using a z-index and then slightly offset in both the x and y direction.

### PROFILE (profile.html)

Profile.html queries data.db according to the current user session using the session object. From here, we display the appropriate college name and coat of arms by performing a query on the “College” table using the appropriate college_id corresponding to the user. The user can also end their user session from this page and log out.

## For ADMIN users:



### CREATE GAME (create.html)
This route is accessed through the flask post method and enables users in an admin session to add table entries to the index page. The user is prompted with a series of javascript forms. The returned values of these forms once submitted are stored in data.db through an INSERT query.


### ADD SCORE/ DELETE (index.html)
Admin users may also modify the score of current and past games (determined using the DateTime Python library) which updates the games SQL table. This in turn updates data relevant to the standings and previous games page (the game is automatically appended to the previous games dictionary).

# Python
## app.py
Through Jinja and flask, the aforementioned functions are implemented on the app.py file as flask routes, interacting with the page through POST and GET methods. Further comments are included on the app.py file.

# Style
## styles.scss
SCSS is a more advanced and evolved variant of the CSS language. In the context of our code, it is used to generate the movement for each SVG image that floats behind the Create Game page. It is also used to import the serif font, which is used on our code.

## styles.css.map
This was created by a command ran in the terminal. The command was sass styles.scss styles.css and it converted all that was written in SCSS in a readable way for CSS.

## styles.css
Here, we included some of the longest stylistic choices of the code. Please note that we opted to include some specifications usually described in CSS already in the html files. This makes it easier to spot any errors while writing and debugging the code. For this reason, you can see that the CSS file is not very long, including only design changes for entire pages and functions, such as colors, fonts, and the nav bar.
